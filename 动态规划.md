# 动态规划

1. 最大自序和

给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

> 输入: [-2,1,-3,4,-1,2,1,-5,4]
> 
> 输出: 6
> 
> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6

---

2. 买卖股票的最佳时机

给定一个数组，它的第 i个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

示例 1:

> 输入: [7,1,5,3,6,4]
> 
> 输出: 5
> 
> 解释: 在第 2天（股票价格=1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
> 
> 注意利润不能是 7-1 = 6,因为卖出价格需要大于买入价格。

示例 2:

> 输入: [7,6,4,3,1]
> 
> 输出: 0
> 
> 解释: 在这种情况下,没有交易完成,所以最大利润为 0。

---

3. 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

> 输入： 2
> 
> 输出： 2
> 
> 解释： 有两种方法可以爬到楼顶。
> 
> 1.  1 阶 + 1 阶
> 2.  2 阶

示例 2：

> 输入： 3
> 
> 输出： 3
> 
> 解释： 有三种方法可以爬到楼顶。
> 
> 1.  1 阶 + 1 阶 + 1 阶
> 2.  1 阶 + 2 阶
> 3.  2 阶 + 1 阶

---

4. 三角形最小路径和

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

示例：

> 给定三角形：
> 
> [  
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2],  
> &nbsp;&nbsp;&nbsp;[3,4],  
> &nbsp;&nbsp;[6,5,7],  
> &nbsp;[4,1,8,3]  
> ]
> > 
> > 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

---

5. 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

![image](https://note.youdao.com/yws/api/personal/file/WEB1d01d90f07972d6aeb3051ff3f16774d?method=download&shareKey=bcf432021fb86309200b7d14a801b41f)

例如，上图是一个7 x 3 的网格。有多少可能的路径？

说明：m 和 n 的值均不超过 100。

示例 1:

> 输入: m = 3, n = 2
> 
> 输出: 3
> 
> 解释:
> 从左上角开始，总共有 3 条路径可以到达右下角。
> 1. 向右 -> 向右 -> 向下
> 2. 向右 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向右

示例 2:

> 输入: m = 7, n = 3
> 
> 输出: 28

---

6. 不同路径II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

![image](https://note.youdao.com/yws/api/personal/file/WEB1d01d90f07972d6aeb3051ff3f16774d?method=download&shareKey=bcf432021fb86309200b7d14a801b41f)

网格中的障碍物和空位置分别用 1 和 0 来表示。

说明：m 和 n 的值均不超过 100。

示例:

> 输入:
> 
> [  
> &nbsp;&nbsp;[0,0,0],  
> &nbsp;&nbsp;[0,1,0],  
> &nbsp;&nbsp;[0,0,0]  
> ]
> 
> 输出: 2
> 
> 解释:3x3 网格的正中间有一个障碍物。
> 从左上角到右下角一共有 2 条不同的路径：
> 1. 向右 -> 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右 -> 向右

---

7. 单词拆分

给定一个非空字符串s和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

- 拆分时可以重复使用字典中的单词。
- 你可以假设字典中没有重复的单词。

示例 1：

> 输入: s = "leetcode", wordDict = ["leet", "code"]
> 
> 输出: true
> 
> 解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。

示例 2：

> 输入: s = "applepenapple", wordDict = ["apple", "pen"]
> 
> 输出: true
> 
> 解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
> 
> 注意你可以重复使用字典中的单词。

示例 3：

> 输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
> 
> 输出: false

---

8. 最小路径和

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:

> 输入:
> 
> [  
> &nbsp;&nbsp;&nbsp;[1,3,1],  
> &nbsp;&nbsp;&nbsp;[1,5,1],  
> &nbsp;&nbsp;&nbsp;[4,2,1]  
> ]
> 
> 输出: 7
> 
> 解释: 因为路径 1→3→1→1→1 的总和最小。

---

9. 编辑距离

给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

示例 1:

> 输入: word1 = "horse", word2 = "ros"
> 
> 输出: 3
> 
> 解释: 
> 
> horse -> rorse (将 'h' 替换为 'r')
> 
> rorse -> rose (删除 'r')
> 
> rose -> ros (删除 'e')

示例 2:

> 输入: word1 = "intention", word2 = "execution"
> 
> 输出: 5
> 
> 解释: 
> 
> intention -> inention (删除 't')
> 
> inention -> enention (将 'i' 替换为 'e')
> 
> enention -> exention (将 'n' 替换为 'x')
> 
> exention -> exection (将 'n' 替换为 'c')
> 
> exection -> execution (插入 'u')

---

10. 最大矩形

给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

示例:

> 输入:
> 
> [  
> &nbsp;&nbsp;&nbsp;["1","0","1","0","0"],  
> &nbsp;&nbsp;&nbsp;["1","0","1","1","1"],  
> &nbsp;&nbsp;&nbsp;["1","1","1","1","1"],  
> &nbsp;&nbsp;&nbsp;["1","0","0","1","0"]  
> ]

输出: 6

---

11. 买卖股票的最佳时机II

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

> 输入: [3,3,5,0,0,3,1,4]
> 
> 输出: 6
> 
> 解释: 
> 
> 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。  
> 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

示例 2:

> 输入: [1,2,3,4,5]
> 
> 输出: 4
> 
> 解释: 
> 
> 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出,这笔交易所能获得利润 = 5-1 = 4 。  
> 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3:

> 输入: [7,6,4,3,1] 
> 
> 输出: 0 
> 
> 解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。

---

12. 不同的子序列

给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。

一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

示例 1:

> 输入: S = "rabbbit", T = "rabbit"
> 
> 输出: 3

示例 2:

> 输入: S = "babgbag", T = "bag"
> 
> 输出: 5

---

13. 分割回文字串II

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。

返回符合要求的最少分割次数。

示例:

> 输入: "aab"
> 
> 输出: 1
> 
> 解释: 进行一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。

---