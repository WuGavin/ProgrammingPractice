# 数字&数据结构

1. 整数反转

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:

> 输入: 123
> 
> 输出: 321

示例 2:

> 输入: -123
> 
> 输出: -321

示例 3:

> 输入: 120
> 
> 输出: 21

注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

---

2. 回文数

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例 1:

> 输入: 121
> 
> 输出: true

示例 2:

> 输入: -121
> 
> 输出: false

解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

示例 3:

> 输入: 10
> 
> 输出: false
> 
> 解释: 从右向左读,为01。因此它不是一个回文数。

---

3. 字符串转换数字

请你来实现一个 atoi 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

说明：

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，qing返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

示例 1:

> 输入: "42"
> 
> 输出: 42

示例 2:

> 输入: "   -42"
> 
> 输出: -42
> 
> 解释: 第一个非空白字符为 '-', 它是一个负号。
> 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。

示例 3:

> 输入: "4193 with words"
> 
> 输出: 4193
> 
> 解释: 转换截止于数字 '3'，因为它的下一个字符不为数字。

示例 4:

> 输入: "words and 987"
> 
> 输出: 0
> 
> 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
>      因此无法执行有效的转换。
     
示例 5:

> 输入: "-91283472332"
> 
> 输出: -2147483648
> 
> 解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
>      因此返回 INT_MIN (−231) 。

---

4. 第K个排列

给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"  
"132"  
"213"  
"231"  
"312"  
"321"  

给定 n 和 k，返回第 k 个排列。

说明：

- 给定 n 的范围是 [1, 9]。
- 给定 k 的范围是[1,  n!]。

示例 1:

> 输入: n = 3, k = 3
> 
> 输出: "213"

示例 2:

> 输入: n = 4, k = 9
> 
> 输出: "2314"

---

5. LRU缓存机制

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。

进阶:

你是否可以在 O(1) 时间复杂度内完成这两种操作？

示例:

> LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );
> 
> cache.put(1, 1);  
> cache.put(2, 2);  
> cache.get(1);       // 返回  1  
> cache.put(3, 3);    // 该操作会使得密钥 2 作废  
> cache.get(2);       // 返回 -1 (未找到)  
> cache.put(4, 4);    // 该操作会使得密钥 1 作废  
> cache.get(1);       // 返回 -1 (未找到)  
> cache.get(3);       // 返回  3  
> cache.get(4);       // 返回  4  

---

6. 数组中的第k个最大元素

在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

示例 1:

> 输入: [3,2,1,5,6,4] 和 k = 2
> 
> 输出: 5

示例 2:

> 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
> 
> 输出: 4

说明:你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

---

7. 链表随机节点

给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点被选的概率一样。

进阶:
如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？

示例:

> // 初始化一个单链表 [1,2,3].  
> ListNode head = new ListNode(1);  
> head.next = new ListNode(2);  
> head.next.next = new ListNode(3);  
> Solution solution = new Solution(head);  
> 
> // getRandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。  
> solution.getRandom();

---

8. 两个有序数组间相加和的top k

给定两个有序数组arr1和arr2，再给定一个整数k，返回来自arr1和arr2的两个数相加和最大的前k个，两个数必须分别来自两个数组

示例：

> 输入：arr1=[5,4,3,2,1]，arr2=[11,9,7,5,3]，k=4
> 
> 输出：[16,15,14,14]

---

9. 有序数组内相加和的top k

给定一个有序数组arr，再给定一个整数k，返回来自arr的两个不同的数相加和最大的前k个，两个数的下标必须是不同的

示例：

> 输入：arr=[5,4,3,2,1]，k=4
> 
> 输出：[9,8,7,7]

---

10. 合并区间

给出一个区间的集合，请合并所有重叠的区间。

示例 1:

> 输入: [[1,3],[2,6],[8,10],[15,18]]
> 
> 输出: [[1,6],[8,10],[15,18]]
> 
> 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

示例 2:

> 输入: [[1,4],[4,5]]
> 
> 输出: [[1,5]]
> 
> 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。

---
