# 图

1. 认识新朋友

小明参加了一个派对，在派对上，小明可以通过朋友认识新的朋友。请问小明最多能多认识哪些朋友？

输入格式：

第一行有三个数字，用空格隔开，第一个数字表示参加派对的总人数n，第二个数字表示派对中相互认识的人的对数m，第三个数字表示哪位是小明。

接下来m行，每行有两个数字，表示这两个人互相认识。

示例：

> 输入：
> 
> 7 6 2  
> 0 1  
> 1 2  
> 3 1  
> 5 1  
> 6 0  
> 2 3  
> 
> 输出：[0,5,6]



---

2. 派对名人

在一个有众多名人的派对上，总有一些明星，所有人都认识他/她，但是他/她却不认识其他所有的人，这种人被称为派对名人。请问派对上谁是派对名人？没有输出-1。

输入格式：

第一行有两个数字，用空格隔开，第一个数字表示参加派对的总人数n，第二个数字表示派对中相互认识的人的对数m。

接下来m行，每行有两个数字a和b，表示a认识b。

示例：

> 输入：
> 
> 4 6  
> 0 1  
> 1 3    
> 2 3  
> 0 3  
> 2 1  
> 2 0 
> 
> 输出：3

---

3. 推荐好友

包含n个用户的朋友列表，对于一个指定用户，找出这个用户最可能认识的人。这个人与当前用户不是朋友，但有最多的共同好友。朋友之间的关系是相互的。如果两个用户都要同样多的共同好友，返回用户序号(从0开始)。如果和所有人都没有共同好友，返回-1。

输入格式：

第一行有两个数字，用空格隔开，第一个数字表示用户人数n，第二个数字表示需要判断的用户的序号m。

接下来n行，每行为对应用户认识的人的列表。

示例：

> 输入：
> 
> 5 0  
> 1 2 3  
> 0 4  
> 0 4  
> 0 4  
> 1 2 3
> 
> 输出：4

---

4. 克隆图

克隆一张无向图，图中的每个节点包含一个 label （标签）和一个 neighbors （邻接点）列表 。

OJ的无向图序列化：

节点被唯一标记。

我们用 # 作为每个节点的分隔符，用 , 作为节点标签和邻接点的分隔符。

例如，序列化无向图 {0,1,2#1,2#2,2}。

该图总共有三个节点, 被两个分隔符  # 分为三部分。 

第一个节点的标签为 0，存在从节点 0 到节点 1 和节点 2 的两条边。
第二个节点的标签为 1，存在从节点 1 到节点 2 的一条边。
第三个节点的标签为 2，存在从节点 2 到节点 2 (本身) 的一条边，从而形成自环。
我们将图形可视化如下：

    图：   
       1
      / \
     /   \
    0 --- 2
         / \
         \_/

---
